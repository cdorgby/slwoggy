name: Amalgamation Build

on:
  # Trigger on new releases/tags
  push:
    tags:
      - 'v*'
  
  # Allow manual triggering (for testing purposes only)
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release'
        required: false
        default: 'development'
        type: choice
        options:
          - development
          - release
          - test

jobs:
  create-amalgamation:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Need full history for git describe to work and to verify tag type
          fetch-depth: 0
          # Initialize submodules for dependencies
          submodules: recursive
      
      - name: Verify release conditions
        id: verify
        run: |
          echo "=== Verifying release conditions ==="
          
          # Get the current tag name
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          echo "Current tag: $TAG_NAME"
          
          # Get the branch name that contains this tag
          # Get the commit hash that the tag points to
          TAG_COMMIT=$(git rev-parse "$TAG_NAME")
          # Get the branch name that contains this tag's commit
          BRANCHES=$(git branch -r --contains "$TAG_COMMIT" | grep -v HEAD | sed 's/.*origin\///')
          echo "Branches containing this tag:"
          echo "$BRANCHES"
          
          # Check if tag is on a proper release branch
          # Pattern: version-X.Y or release-X.Y or release/X.Y or version/X.Y
          VALID_BRANCH="false"
          for BRANCH in $BRANCHES; do
            if echo "$BRANCH" | grep -qE '^(version|release)[-/][0-9]+\.[0-9]+$'; then
              echo "✓ Found valid release branch: $BRANCH"
              VALID_BRANCH="true"
              RELEASE_BRANCH="$BRANCH"
              break
            fi
          done
          
          if [ "$VALID_BRANCH" = "false" ]; then
            echo "✗ Tag is not on a properly named release branch"
            echo "  Expected pattern: version-X.Y or release-X.Y"
          fi
          
          # Verify tag format matches branch version
          if [ "$VALID_BRANCH" = "true" ]; then
            # Extract version from branch name (e.g., version-0.1 -> 0.1)
            BRANCH_VERSION=$(echo "$RELEASE_BRANCH" | sed -E 's/^(version|release)[-\/]//')
            
            # Check if tag starts with v followed by the branch version
            if echo "$TAG_NAME" | grep -qE "^v${BRANCH_VERSION}\.[0-9]+"; then
              echo "✓ Tag version matches branch version"
              VERSION_MATCH="true"
            else
              echo "✗ Tag $TAG_NAME doesn't match branch version $BRANCH_VERSION"
              echo "  Expected pattern: v${BRANCH_VERSION}.x"
              VERSION_MATCH="false"
            fi
          else
            VERSION_MATCH="false"
          fi
          
          # Final decision
          if [ "$VALID_BRANCH" = "true" ] && [ "$VERSION_MATCH" = "true" ]; then
            echo ""
            echo "=== All release conditions met ✓ ==="
            echo "proceed=true" >> $GITHUB_OUTPUT
            echo "branch=$RELEASE_BRANCH" >> $GITHUB_OUTPUT
          else
            echo ""
            echo "=== Release conditions NOT met ✗ ==="
            echo "Requirements:"
            echo "  1. Tag must be on a release branch (version-X.Y or release-X.Y)"
            echo "  2. Tag version must match branch (e.g., v0.1.x for version-0.1)"
            echo ""
            echo "Skipping amalgamation build for main branch"
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 0  # Exit successfully but skip remaining steps
          fi
      
      - name: Setup Python
        if: steps.verify.outputs.proceed == 'true'
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      
      - name: Install dependencies
        if: steps.verify.outputs.proceed == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y g++ python3
      
      - name: Generate amalgamation
        if: steps.verify.outputs.proceed == 'true'
        run: |
          echo "Creating slwoggy amalgamation build..."
          ./create-amalgamation.sh
          
          # Verify the amalgamation was created successfully
          if [ ! -f "amalgamation/slwoggy.hpp" ]; then
            echo "ERROR: Amalgamation failed - slwoggy.hpp not found"
            exit 1
          fi
          
          # Get file stats for logging
          echo "Amalgamation created successfully:"
          echo "  File: amalgamation/slwoggy.hpp"
          echo "  Size: $(wc -c < amalgamation/slwoggy.hpp) bytes"
          echo "  Lines: $(wc -l < amalgamation/slwoggy.hpp) lines"
      
      - name: Get version info
        if: steps.verify.outputs.proceed == 'true'
        id: version
        run: |
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          
          # Set a clean name for the artifact
          if [[ "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            CLEAN_VERSION=${VERSION#v}  # Remove 'v' prefix
            echo "clean_version=$CLEAN_VERSION" >> $GITHUB_OUTPUT
            echo "artifact_name=slwoggy-$CLEAN_VERSION" >> $GITHUB_OUTPUT
          else
            echo "clean_version=$VERSION" >> $GITHUB_OUTPUT
            echo "artifact_name=slwoggy-$VERSION" >> $GITHUB_OUTPUT
          fi
      
      - name: Create build package
        if: steps.verify.outputs.proceed == 'true'
        run: |
          # Create a clean directory for the build
          mkdir -p slwoggy-build
          
          # Copy the amalgamated header
          cp amalgamation/slwoggy.hpp slwoggy-build/
          
          # Copy documentation
          cp README.md slwoggy-build/
          cp LICENSE slwoggy-build/
          
          # Create a simple usage example
          cat > slwoggy-build/example.cpp << 'EOF'
          #include "slwoggy.hpp"
          
          using namespace slwoggy;
          
          int main() {
              // Configure a simple console sink
              auto console_sink = make_console_sink();
              log_line_dispatcher::instance().add_sink(console_sink);
              
              // Basic logging examples
              LOG(info) << "Hello from slwoggy!" << endl;
              LOG(debug) << "This is a debug message" << endl;
              LOG(warn) << "This is a warning" << endl;
              
              // Structured logging example
              LOG_STRUCTURED(info)
                  .add("user", "alice")
                  .add("action", "login")
                  .add("ip", "192.168.1.100") << "User login successful" << endl;
              
              // Wait for all logs to be written
              log_line_dispatcher::instance().flush();
              
              return 0;
          }
          EOF
          
          # Create a simple build script
          cat > slwoggy-build/build-example.sh << 'EOF'
          #!/bin/bash
          echo "Building slwoggy example..."
          g++ -std=c++20 -O2 -pthread example.cpp -o example
          echo "Done! Run './example' to test."
          EOF
          chmod +x slwoggy-build/build-example.sh
          
          # Create README for the build package
          cat > slwoggy-build/BUILD_README.md << EOF
          # slwoggy Single-Header Build
          
          This package contains a single-header build of the slwoggy logging library.
          
          ## Version
          
          **slwoggy version:** ${{ steps.version.outputs.version }}
          
          ## Contents
          
          - \`slwoggy.hpp\` - The complete single-header library
          - \`README.md\` - Full project documentation  
          - \`LICENSE\` - MIT license
          - \`example.cpp\` - Simple usage example
          - \`build-example.sh\` - Script to build the example
          
          ## Quick Start
          
          1. Copy \`slwoggy.hpp\` to your project
          2. Include it: \`#include "slwoggy.hpp"\`
          3. Compile with C++20: \`g++ -std=c++20 -pthread your_file.cpp\`
          
          ## Example Usage
          
          \`\`\`cpp
          #include "slwoggy.hpp"
          
          using namespace slwoggy;
          
          int main() {
              auto console_sink = make_console_sink();
              log_line_dispatcher::instance().add_sink(console_sink);
              
              LOG(info) << "Hello from slwoggy!" << endl;
              log_line_dispatcher::instance().flush();
              return 0;
          }
          \`\`\`
          
          For complete documentation, see \`README.md\`.
          EOF
          
          echo "Build package created in slwoggy-build/"
          ls -la slwoggy-build/
      
      - name: Upload build artifact
        if: steps.verify.outputs.proceed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.version.outputs.artifact_name }}
          path: slwoggy-build/
          retention-days: 90
      
      - name: Commit amalgamation to release branch
        if: steps.verify.outputs.proceed == 'true'
        run: |
          echo "Committing amalgamation to release branch: ${{ steps.verify.outputs.branch }}"
          
          # Validate branch name format for safety
          if ! echo "${{ steps.verify.outputs.branch }}" | grep -qE '^[a-zA-Z0-9._/-]+$'; then
            echo "Error: Invalid branch name format"
            exit 1
          fi
          
          # Configure git
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Validate that amalgamation was actually created
          if [ ! -d "amalgamation" ]; then
            echo "Error: amalgamation directory not found after generation"
            exit 1
          fi
          
          if [ ! -f "amalgamation/slwoggy.hpp" ]; then
            echo "Error: amalgamation/slwoggy.hpp not found"
            exit 1
          fi
          
          # Save the generated amalgamation before switching branches
          echo "Saving generated amalgamation..."
          cp -r amalgamation /tmp/amalgamation.generated
          
          # Fetch latest remote refs
          git fetch origin
          
          # Switch to the release branch (create local tracking branch if needed)
          git checkout -B "${{ steps.verify.outputs.branch }}" "origin/${{ steps.verify.outputs.branch }}"
          
          # Safely replace amalgamation directory
          if [ -d "amalgamation" ]; then
            echo "Updating existing amalgamation..."
            rm -rf amalgamation.backup
            mv amalgamation amalgamation.backup
          else
            echo "Creating new amalgamation directory..."
          fi
          
          # Move the generated amalgamation into place
          mv /tmp/amalgamation.generated amalgamation
          
          # Add and commit if there are changes (force-add since amalgamation is in .gitignore)
          git add -f amalgamation/
          if git diff --staged --quiet; then
            echo "No changes to amalgamation, skipping commit"
          else
            # Use heredoc for proper multi-line commit message
            cat > /tmp/commit_msg <<EOF
          Update amalgamation for ${{ steps.version.outputs.version }}
          
          Generated from tag ${{ steps.version.outputs.version }}
          [skip ci]
          EOF
            # Use single-line commit message to avoid YAML heredoc indentation issues
            git commit -m "Update amalgamation for ${{ steps.version.outputs.version }} [skip ci]"
            
            # Push to the release branch
            git push origin "${{ steps.verify.outputs.branch }}"
            echo "✓ Amalgamation committed to ${{ steps.verify.outputs.branch }}"
          fi
      
      - name: Create release (for tagged versions)
        if: steps.verify.outputs.proceed == 'true' && startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v1
        with:
          files: |
            slwoggy-build/slwoggy.hpp
            slwoggy-build/BUILD_README.md
            slwoggy-build/example.cpp
            slwoggy-build/build-example.sh
          body: |
            # slwoggy ${{ steps.version.outputs.version }} - Single-Header Build
            
            This release contains the amalgamated single-header version of slwoggy.
            
            ## Quick Download
            
            **For most users:** Download the `slwoggy.hpp` file below and include it in your project.
            
            ## What's Included
            
            - `slwoggy.hpp` - Complete single-header library (~1MB)
            - `BUILD_README.md` - Quick start guide
            - `example.cpp` - Usage example
            - `build-example.sh` - Build script for the example
            
            ## Usage
            
            ```cpp
            #include "slwoggy.hpp"
            
            using namespace slwoggy;
            
            int main() {
                auto console_sink = make_console_sink();
                log_line_dispatcher::instance().add_sink(console_sink);
                
                LOG(info) << "Hello from slwoggy!" << endl;
                log_line_dispatcher::instance().flush();
                return 0;
            }
            ```
            
            Compile with: `g++ -std=c++20 -pthread your_file.cpp`
            
            ## Full Documentation
            
            See the main [README](https://github.com/cdorgby/slwoggy/blob/main/README.md) for complete documentation.
            
            ---
            
            **File sizes:**
            - slwoggy.hpp: ~$(du -h slwoggy-build/slwoggy.hpp | cut -f1)
            - Total lines: $(wc -l < slwoggy-build/slwoggy.hpp)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}